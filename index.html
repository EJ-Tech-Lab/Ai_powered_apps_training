<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pea AI - Multi Thread</title>
    <style>
        :root {
            --sidebar-width: 260px;
            --primary-color: #007bff;
            --bg-color: #f4f4f9;
            --sidebar-bg: #202123;
            --sidebar-text: #ececf1;
            --sidebar-hover: #2A2B32;
        }

        body, html { margin: 0; padding: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; height: 100%; background: var(--bg-color); overflow: hidden; }

        /* APP LAYOUT */
        #app-container { display: flex; height: 100vh; width: 100vw; }
        
        /* SIDEBAR */
        #sidebar {
            width: var(--sidebar-width);
            background: var(--sidebar-bg);
            color: var(--sidebar-text);
            display: flex;
            flex-direction: column;
            padding: 10px;
            flex-shrink: 0;
            transition: transform 0.3s ease;
        }
        
        #new-chat-btn {
            border: 1px solid #565869;
            border-radius: 5px;
            padding: 12px;
            background: transparent;
            color: white;
            cursor: pointer;
            text-align: left;
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
            transition: background 0.2s;
        }
        #new-chat-btn:hover { background: var(--sidebar-hover); }

        .thread-list { flex: 1; overflow-y: auto; display: flex; flex-direction: column; gap: 5px; }
        .thread-item {
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.9rem;
            color: #ececf1;
            text-decoration: none;
        }
        .thread-item:hover { background: var(--sidebar-hover); }
        .thread-item.active { background: #343541; }
        .thread-title { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 180px; }
        .delete-btn { opacity: 0; color: #aaa; cursor: pointer; font-size: 1.1rem; background: none; border: none; }
        .thread-item:hover .delete-btn { opacity: 1; }
        .delete-btn:hover { color: #ff4d4d; }

        /* MAIN CHAT AREA */
        #main-area { flex: 1; display: flex; flex-direction: column; height: 100%; position: relative; background: white; }
        
        .chat-header { padding: 15px 20px; border-bottom: 1px solid #eee; display: flex; justify-content: space-between; align-items: center; background: #fff; }
        .chat-header h1 { margin: 0; font-size: 1.2rem; display: flex; align-items: center; gap: 10px; }
        .meta { font-size: 0.8rem; color: #666; }
        #logout-btn { padding: 5px 10px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer; }

        #messages-container { flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 20px; scroll-behavior: smooth; }
        
        /* Message Bubbles */
        .message { max-width: 800px; margin: 0 auto; width: 100%; display: flex; gap: 15px; }
        .message.user { justify-content: flex-end; }
        .message.aibot { justify-content: flex-start; }
        
        .bubble { padding: 10px 15px; border-radius: 8px; line-height: 1.5; font-size: 1rem; max-width: 70%; word-wrap: break-word; }
        .user .bubble { background: var(--primary-color); color: white; }
        .aibot .bubble { background: #f7f7f8; color: #333; border: 1px solid #eee; }
        
        /* Markdown Styling */
        .bubble pre { background: #2d2d2d; color: #fff; padding: 10px; border-radius: 6px; overflow-x: auto; }
        .bubble code { font-family: monospace; }
        
        /* Input Area */
        .input-area { padding: 20px; border-top: 1px solid #eee; display: flex; justify-content: center; background: white; }
        .chat-form { width: 100%; max-width: 800px; display: flex; gap: 10px; align-items: flex-end; border: 1px solid #ddd; padding: 10px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
        textarea { flex: 1; border: none; resize: none; outline: none; max-height: 150px; font-family: inherit; }
        .chat-form button { background: none; border: none; cursor: pointer; font-size: 1.2rem; color: #666; transition: color 0.2s; }
        .chat-form button:hover { color: var(--primary-color); }

        /* Login Modal */
        #login-popup { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 2000; }
        #login-card { background: white; padding: 2rem; border-radius: 12px; width: 320px; text-align: center; box-shadow: 0 4px 25px rgba(0,0,0,0.2); }
        #login-card input { width: 90%; padding: 10px; margin: 8px 0; border: 1px solid #ccc; border-radius: 5px; }
        #login-card button { width: 95%; padding: 10px; margin-top: 15px; background: var(--primary-color); color: white; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; }
        #switch-mode { margin-top: 15px; font-size: 0.85rem; color: var(--primary-color); cursor: pointer; }

        @media (max-width: 768px) {
            #sidebar { position: absolute; height: 100%; transform: translateX(-100%); z-index: 100; }
            #sidebar.open { transform: translateX(0); }
            #mobile-menu-btn { display: block; }
        }
    </style>
</head>
<body>

    <div id="login-popup">
        <div id="login-card">
            <h3 id="login-title">Sign in</h3>
            <input id="login-email" type="email" placeholder="Email" />
            <input id="login-pass" type="password" placeholder="Password" />
            <input id="login-pass2" type="password" placeholder="Confirm password" style="display:none;" />
            <button id="login-btn">Login</button>
            <p id="login-error" style="color:red; font-size: 0.9rem; margin-top: 5px;"></p>
            <div id="switch-mode">Don't have an account? Sign up</div>
        </div>
    </div>

    <div id="app-container">
        
        <aside id="sidebar">
            <button id="new-chat-btn" onclick="createNewThread()">
                <span>+</span> New Chat
            </button>
            <div class="thread-list" id="thread-list">
                </div>
            <div style="margin-top: auto; font-size: 0.8rem; text-align: center; color: #666; padding: 10px;">
                Pea AI v2.0
            </div>
        </aside>

        <main id="main-area">
            <div class="chat-header">
                <h1>Pea ü´õ</h1>
                <div class="meta" id="who">Not signed in</div>
                <button id="logout-btn">Logout</button>
            </div>

            <div id="messages-container">
                <div style="text-align:center; color:#ccc; margin-top: 50px;">Select a conversation or start a new one.</div>
            </div>

            <div class="input-area">
                <form class="chat-form" id="message-form">
                    <button type="button" id="file-btn" title="Upload">üìé</button>
                    <input type="file" id="file-input" style="display:none;" multiple />
                    
                    <textarea id="message-input" placeholder="Send a message..." rows="1"></textarea>
                    
                    <button type="button" id="mic-btn" title="Speak">üé§</button>
                    <button type="submit">‚û§</button>
                </form>
            </div>
        </main>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
        const API_BASE = "https://ej-0-training.hf.space";

        // DOM Elements
        const messagesContainer = document.getElementById('messages-container');
        const messageForm = document.getElementById('message-form');
        const messageInput = document.getElementById('message-input');
        const threadListEl = document.getElementById('thread-list');
        const micBtn = document.getElementById('mic-btn');
        const whoEl = document.getElementById('who');
        
        // Auth Elements
        const loginPopup = document.getElementById('login-popup');
        const loginBtn = document.getElementById('login-btn');
        const loginEmail = document.getElementById('login-email');
        const loginPass = document.getElementById('login-pass');
        const loginPass2 = document.getElementById('login-pass2');
        const loginTitle = document.getElementById('login-title');
        const loginError = document.getElementById('login-error');
        const switchMode = document.getElementById('switch-mode');
        const logoutBtn = document.getElementById('logout-btn');
        const fileBtn = document.getElementById("file-btn");
        const fileInput = document.getElementById("file-input");

        // State
        let ACCESS_TOKEN = null;
        let REFRESH_TOKEN = null;
        let CURRENT_EMAIL = null;
        let CURRENT_THREAD_ID = null; // New: Track active conversation
        let isSignupMode = false;

        /* =================== THREAD MANAGEMENT =================== */

        function renderThreadList(threads) {
            threadListEl.innerHTML = "";
            threads.forEach(thread => {
                const div = document.createElement("div");
                div.className = `thread-item ${thread.id === CURRENT_THREAD_ID ? 'active' : ''}`;
                div.innerHTML = `
                    <span class="thread-title" onclick="switchToThread('${thread.id}')">
                        ${thread.title || 'New Chat'}
                    </span>
                    <button class="delete-btn" onclick="deleteThread('${thread.id}', event)">üóëÔ∏è</button>
                `;
                threadListEl.appendChild(div);
            });
        }

        async function createNewThread() {
            if (!ACCESS_TOKEN) return;
            try {
                const res = await fetch(API_BASE + "/threads", {
                    method: "POST",
                    headers: { "Authorization": "Bearer " + ACCESS_TOKEN }
                });
                const data = await res.json();
                if (data.thread_id) {
                    CURRENT_THREAD_ID = data.thread_id;
                    // Refresh sidebar
                    loadThreads(); 
                    // Clear UI
                    messagesContainer.innerHTML = "";
                    addMessage("Started a new conversation.", "aibot");
                }
            } catch (e) { console.error("Create thread failed", e); }
        }

        async function loadThreads() {
            try {
                const res = await fetch(API_BASE + "/threads", {
                    headers: { "Authorization": "Bearer " + ACCESS_TOKEN }
                });
                const data = await res.json();
                renderThreadList(data.threads || []);
            } catch (e) { console.error("Load threads failed", e); }
        }

        async function switchToThread(threadId) {
            if (CURRENT_THREAD_ID === threadId) return;
            CURRENT_THREAD_ID = threadId;
            messagesContainer.innerHTML = '<div style="text-align:center;color:#999;">Loading...</div>';
            
            // Highlight active in sidebar
            loadThreads(); // Simple re-render to update 'active' class

            try {
                const res = await fetch(API_BASE + `/threads/${threadId}/messages`, {
                    headers: { "Authorization": "Bearer " + ACCESS_TOKEN }
                });
                const data = await res.json();
                messagesContainer.innerHTML = "";
                if (data.messages && data.messages.length > 0) {
                    data.messages.forEach(m => addMessage(m.content, m.role === 'user' ? 'user' : 'aibot'));
                } else {
                    addMessage("Start chatting in this thread!", "aibot");
                }
            } catch (e) {
                messagesContainer.innerHTML = "Error loading messages.";
            }
        }

        async function deleteThread(threadId, event) {
            event.stopPropagation(); // Prevent clicking the parent div
            if (!confirm("Delete this chat?")) return;

            try {
                await fetch(API_BASE + `/threads/${threadId}`, {
                    method: "DELETE",
                    headers: { "Authorization": "Bearer " + ACCESS_TOKEN }
                });
                
                if (CURRENT_THREAD_ID === threadId) {
                    CURRENT_THREAD_ID = null;
                    messagesContainer.innerHTML = '<div style="text-align:center; color:#ccc; margin-top:50px;">Thread deleted. Start a new one.</div>';
                }
                loadThreads();
            } catch (e) { alert("Failed to delete thread"); }
        }

        /* =================== CHAT UI =================== */

        function addMessage(text, role) {
            const wrapper = document.createElement("div");
            wrapper.className = "message " + role;
            
            const bubble = document.createElement("div");
            bubble.className = "bubble";
            bubble.innerHTML = text ? marked.parse(text) : '<span class="typing">...</span>';
            
            wrapper.appendChild(bubble);
            messagesContainer.appendChild(wrapper);
            messagesContainer.scrollTo(0, messagesContainer.scrollHeight);
            
            return bubble; 
        }

        async function sendMessage(text) {
            if (!ACCESS_TOKEN) return alert("Please login first.");
            
            // If no thread selected, create one first
            if (!CURRENT_THREAD_ID) {
                await createNewThread();
            }

            addMessage(text, "user");
            const botBubble = addMessage("", "aibot");

            try {
                const res = await fetch(API_BASE + "/chatbot", {
                    method: "POST",
                    headers: { 
                        "Content-Type": "application/json", 
                        "Authorization": "Bearer " + ACCESS_TOKEN 
                    },
                    body: JSON.stringify({ 
                        prompt: text,
                        thread_id: CURRENT_THREAD_ID // <--- CRITICAL UPDATE
                    })
                });

                if (res.status === 401) {
                    if (await refreshAccessToken()) return sendMessage(text);
                    botBubble.innerText = "Session expired."; loginPopup.style.display="flex"; return;
                }

                const reader = res.body.getReader();
                const decoder = new TextDecoder();
                let fullText = "";

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;
                    fullText += decoder.decode(value, { stream: true });
                    botBubble.innerHTML = marked.parse(fullText);
                    messagesContainer.scrollTo(0, messagesContainer.scrollHeight);
                }
            } catch (err) {
                botBubble.innerText = "Error: " + err.message;
            }
        }

        /* =================== AUTHENTICATION =================== */

        loginBtn.onclick = async () => {
            loginError.innerText = "";
            const email = loginEmail.value.trim();
            const password = loginPass.value.trim();
            if(!email || !password) return loginError.innerText="Fill all fields";

            const endpoint = isSignupMode ? "/signup" : "/login";
            
            try {
                const res = await fetch(API_BASE + endpoint, {
                    method: "POST", headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ email, password: isSignupMode && loginPass2.value ? loginPass.value : password })
                });
                const data = await res.json();
                
                if (!data.success) return loginError.innerText = data.message || "Error";
                
                if (isSignupMode) {
                    alert("Account created. Please login.");
                    isSignupMode = false; switchMode.click();
                    return;
                }

                // Login Success
                ACCESS_TOKEN = data.access_token;
                REFRESH_TOKEN = data.refresh_token;
                CURRENT_EMAIL = email;
                
                loginPopup.style.display = "none";
                whoEl.innerText = email;
                
                // Render Threads from login response
                if (data.threads) renderThreadList(data.threads);
                
                messagesContainer.innerHTML = '<div style="text-align:center; margin-top:50px;">Welcome! Select a chat or start new.</div>';

            } catch (e) { loginError.innerText = "Network Error"; }
        };

        async function refreshAccessToken() {
            if (!REFRESH_TOKEN) return false;
            try {
                const res = await fetch(API_BASE + "/auth/refresh", {
                    method: "POST", headers: {"Content-Type":"application/json"},
                    body: JSON.stringify({refresh_token: REFRESH_TOKEN})
                });
                if(!res.ok) return false;
                const data = await res.json();
                ACCESS_TOKEN = data.access_token;
                REFRESH_TOKEN = data.refresh_token;
                return true;
            } catch(e) { return false; }
        }

        logoutBtn.onclick = async () => {
            if(REFRESH_TOKEN) await fetch(API_BASE+"/logout", {method:"POST", headers:{"Authorization": "Bearer "+ACCESS_TOKEN}, body:JSON.stringify({refresh_token: REFRESH_TOKEN})});
            ACCESS_TOKEN=null; REFRESH_TOKEN=null; CURRENT_EMAIL=null; CURRENT_THREAD_ID=null;
            threadListEl.innerHTML = "";
            messagesContainer.innerHTML = "";
            loginPopup.style.display="flex";
        };

        switchMode.onclick = () => {
            isSignupMode = !isSignupMode;
            loginTitle.innerText = isSignupMode ? "Sign up" : "Sign in";
            loginBtn.innerText = isSignupMode ? "Create Account" : "Login";
            switchMode.innerText = isSignupMode ? "Have an account? Sign in" : "No account? Sign up";
            loginPass2.style.display = isSignupMode ? "block" : "none";
        };

        /* =================== EVENT LISTENERS =================== */
        
        messageForm.onsubmit = (e) => {
            e.preventDefault();
            const text = messageInput.value.trim();
            if(!text) return;
            messageInput.value = "";
            sendMessage(text);
        };

        // Initialize
        setInterval(() => { if(ACCESS_TOKEN) refreshAccessToken(); }, 10*60*1000);
        
        // Auto-login check
        (async () => {
            if (await refreshAccessToken()) {
                loginPopup.style.display = "none";
                whoEl.innerText = "Session Restored";
                loadThreads(); // Fetch threads on restore
            }
        })();

        // File and Mic (Keep existing simple implementation)
        fileBtn.onclick = () => fileInput.click();
        fileInput.onchange = async () => { /* Same as before, just add thread_id check if needed in future */ };
        
        let mediaRecorder; let audioChunks = []; let isRec=false;
        micBtn.onclick = async () => {
            if(!isRec) {
                const stream = await navigator.mediaDevices.getUserMedia({audio:true});
                mediaRecorder = new MediaRecorder(stream);
                mediaRecorder.ondataavailable = e => audioChunks.push(e.data);
                mediaRecorder.onstop = async () => {
                    const blob = new Blob(audioChunks, {type:"audio/webm"});
                    const fd = new FormData(); fd.append("file", blob, "voice.webm");
                    const res = await fetch(API_BASE+"/asr", {method:"POST", body:fd});
                    const d = await res.json();
                    if(d.text) { messageInput.value=d.text; sendMessage(d.text); }
                };
                audioChunks=[]; mediaRecorder.start(); isRec=true; micBtn.innerText="‚èπÔ∏è";
            } else { mediaRecorder.stop(); isRec=false; micBtn.innerText="üé§"; }
        };
    </script>
</body>
</html>
